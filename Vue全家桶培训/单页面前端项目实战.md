# 单页面前后端分离应用实战
单页Web应用（single page web application，SPA），顾名思义就是只有一个html页面的web应用，页面跳转，样式动态渲染等用户交互，全部由JavaScript来控制，这样不需要刷新整个页面实现跳转，页面静态资源不需要重复引用，需要渲染这么内容是异步加载，所以速度快，体验更好，web app能有native app的速度和流畅。由于是单页面，如果所有代码都写在一个页面的话显然是不合理的，所以模块化就显得非常重要。
## 实战项目会员管理系统介绍
会员管理系统，基于**Vue+Vuex+Element+Axios**开发的前后端分离，由**MockJS**服务提供模拟数据接口。包括**登录、注销、修改密码、首页、会员管理、供应商管理、商品管理、用户管理**模块。
示例项目代码已开源到码云上：https://gitee.com/pjhpeter/vue-project.git

效果如下：

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/194640_677241b8_5449551.png "屏幕截图.png")

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/194941_ddefad9e_5449551.png "屏幕截图.png")

## MockJS介绍
### 什么是MockJS
MockJS是可以根据一定规则生成虚拟数据的工具，前后端分离的开发模式，前端开发人员都是根据Web API文档用MockJS来模拟真实数据，从而实现模拟向后端发送请求，获取响应数据的。

官方文档在这：https://github.com/nuysoft/Mock/wiki

### MockJS语法
```json
"name|rule": value
```
MockJS语法采用数据模板定义规范（DTD），分成三部分

+ name：名称
+ rule：规则，同样的规则根据value的数据类型不同会有不同效果
+ value：值

值可以用@占位符来表明调用MockJS的Random对象方法

### 举个例子

1. 创建mock-demo项目，并用Yarn初始化
2. 按照MockJS
```cmd
yarn add mockjs -D
```
3. 在项目根目录创建test.js
```js
const Mock = require('mockjs')

const data = Mock.mock({
    'list|10': [ // list的规则为10，list是数组，该规则的意思是创建10个元素
        {
            'id': 1,
            'name': '张三'
        }
    ]
})

console.log(data)
```
4. 用NodeJS来运行看效果
```cmd
node test
```

效果如下：

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/202514_cde583c6_5449551.png "屏幕截图.png")

> list数组生成了10个元素，但是每个元素都是一样的，这显然不是我们想要的模拟真实数据

5. 再修改一下test.js

```js
const Mock = require('mockjs')

const data = Mock.mock({
    'list|10': [ // list的规则为10，list是数组，该规则的意思是创建10个元素
        {
            'id|+1': 1, // id添加了+1的规则，id是数字类型，所以会从value开始自增1
            'name': '@cname' // value用了@占位符，这里代表调用了Mock的Random对象的cname方法，随机生成中文姓名
        }
    ]
})

console.log(data)
```

再执行一次

```cmd
node test
```

效果如下：

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/203327_fd08068c_5449551.png "屏幕截图.png")

## RAP2

### 什么是RAP2

RAP2是有阿里巴巴提供的免费MockJS数据模拟服务平台。

官网在这：http://rap2.taobao.org/

### RAP2使用

1. 注册账号并登录

2. 新建仓库mock-demo

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/204604_7d59fc14_5449551.png "屏幕截图.png")

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/204744_414da80a_5449551.png "屏幕截图.png")

3. 进入mock-demo仓库新建模块

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/205014_b5afcf53_5449551.png "屏幕截图.png")

4. 新建接口

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/205241_68260d42_5449551.png "屏幕截图.png")

5. 点击编辑，找到响应内容一栏，点击导入

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/205432_9d5b2a7f_5449551.png "屏幕截图.png")

6. 将写入json数据

```json
{
    "list|10": [
        {
            "id|+1": 1,
            "name": "@cname"
        }
    ]
}
```

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/205722_a907c530_5449551.png "屏幕截图.png")

保存后效果如下：

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/205838_aef2fa7d_5449551.png "屏幕截图.png")

> list只有1个元素，并不是我们想要的效果，我们的规则是要给list创建10个元素
> 原因是RAP2的bug，导入JSON的时候，规则会被忽略
> 解决方法在上面生成的响应内容中修改

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/210239_ff84815d_5449551.png "屏幕截图.png")

这时响应数据就是我们想要的了

> 编辑完接口一定要记得保存

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/210350_7e904262_5449551.png "屏幕截图.png")

7. 测试接口

点击下图的地址就可以测试接口，**但是只能测试get请求**

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/210817_c7489bce_5449551.png "屏幕截图.png")

效果如下：

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/211014_3d44cb15_5449551.png "屏幕截图.png")

> 记住红色圈围住的地址，这个就是你的仓库地址，以后在这个仓库创建的所有接口都要用这个地址来访问
> 这里只是简单普及一下MockJS的使用，具体怎么在前端开发中使用后面做项目会讲解

## 项目环境搭建
### 安装Vue CLI
**这里为了演示方便选择的全局安装，真实项目中最好还是局部安装**
```cmd
yarn global add @vue/cli -D
```

### 基于Vue CLI 4 .x创建项目
创建项目vue-member-manager
```cmd
vue create vue-member-manager
```
+ 选这4项：

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/212116_d975ded3_5449551.png "屏幕截图.png")

+ 不用历史路由
+ 选第4项

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/212434_72025a77_5449551.png "屏幕截图.png")

+ 选第1项

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/212538_8859f447_5449551.png "屏幕截图.png")

+ 选第1项

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/212715_c0b55b25_5449551.png "屏幕截图.png")

### 启动测试
```cmd
cd vue-member-manager
yarn serve
```

看到效果就创建成功了

![输入图片说明](https://images.gitee.com/uploads/images/2019/1226/213534_fa9921c2_5449551.png "屏幕截图.png")

### 项目初始化
#### 修改public/index.html
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title>会员管理系统</title>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
```
#### 更换ICO图标
+ 找一个.ico小图标替换public/favicon.ico
+ 然后清除浏览器缓存，一定要选**时间不限**
#### 删除这3个文件
![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/004428_404f7d01_5449551.png "屏幕截图.png")
#### 修改src/router/index.js
```js
import Vue from "vue";
import VueRouter from "vue-router";

Vue.use(VueRouter);

const routes = [];

const router = new VueRouter({
  routes
});

export default router;
```
#### 修改src/App.vue
```vue
<template>
  <div id="app"></div>
</template>

<style></style>
```
#### 配置vue.config.js
在项目根目录下创建vue.config.js
```js
// Vue CLI将webpack.config.js封装起来，不建议我们直接修改，用vue.config.js来代替
module.exports = {
    devServer: {
        port: 8888, // 端口号
        host: 'localhost', // 主机名
        https: false, // 是否启用https协议访问应用
        open: true // 是否项目启动后马上打开浏览器访问
    },

    lintOnSave: false, // 是否开启保存时进行代码检查
    productionSourceMap: false // 打包时不会生成.map文件，加快打包速度
}
```
> Vue CLI将webpack.config.js封装起来，不建议我们直接修改，用vue.config.js来代替
> 配置项参考文档：https://cli.vuejs.org/zh/config/

#### 安装第三方库
+ 安装Axios
```cmd
yarn add axios
```
+ 安装Element UI
```cmd
yarn add element-ui
```
Element UI时基于Vue的前端UI组件，Vue本身不具备UI组件功能，使用Element UI给Vue提供UI功能。
Elemnt UI官网在这：https://element.eleme.cn/

#### 整合Element UI
+ 修改src/main.js
```js
import Vue from "vue";
import ElementUI from "element-ui"; // 引入Element UI
import "element-ui/lib/theme-chalk/index.css"; // 引入Element UI的默认样式
import App from "./App.vue";
import router from "./router";
import store from "./store";

// 使用Element UI
Vue.use(ElementUI);

// 消息提示环境配置，是否生产环境
// 开发环境下，Vue会提供很多警告信息，方便调试代码
// 生产环境下，Vue只会提供必要的错误信息
// process.env是全局环境变量，NODE_ENV是production或者development
Vue.config.productionTip = process.env.NODE_ENV === 'production';

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount("#app");
```
#### 安装两个vscode插件
+ HTML CSS Support
提供HTML和CSS的快捷提示

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/003911_b51c1f89_5449551.png "屏幕截图.png")

+ Element UI Snippets
提供Element UI的快捷提示

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/004005_fe8e7daa_5449551.png "屏幕截图.png")

### 封装Axios
#### 编写request.js
在src目录下创建uitls目录，然后创建src/utils/request.js
```js
// 引入axios
import axios from 'axios'

// 创建一个axios对象
const request = axios.create({
    // 请求配置参考: https://github.com/axios/axios#request-config
    // baseURL参数是所有请求的路径前缀
    // 比如baseURL: '/dev-api'，调用axios.get('/test')，真正的请求路径是/dev-api/test
    baseURL: '/',
    timeout: 5000
})

// 导出request对象
export default request
```
#### 测试一下
1. 在public目录下创建db.json
```json
[
    {"id": 1, "name": "嬴政"},
    {"id": 2, "name": "百里守约"},
    {"id": 3, "name": "亚瑟"}
]
```
2. 在src目录下创建api目录，然后创建src/api/test.js
```js
// 引入request
import request from '@/utils/request' // @符号是代表src的绝对路径

// public目录下的内容打包后会在项目根目录中，所以这里不需要加public路径
request.get('http://localhost:8888/db.json').then(response => {
    console.log(response.data);
})
```
3. 修改App.vue
```vue
<template>
  <div id="app"></div>
</template>

<script>
// 引入test.js测试axios封装
import testAPI from '@/api/test'

export default {
  
}
</script>

<style></style>
```
4. 启动服务查看结果
```cmd
yarn serve
```
![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/012859_c98232c2_5449551.png "屏幕截图.png")

#### 访问RAP2的test接口
1. 修改test.js
```js
// 引入request
import request from '@/utils/request' // @符号是代表src的绝对路径

request.get('http://rap2api.taobao.org/app/mock/240993/test').then(response => {
    console.log(response.data);
})
```
2. 看效果

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/121231_4e032596_5449551.png "屏幕截图.png")

3. 把数据渲染到App.vue中

**修改test.js**

```js
// 引入request
import request from '@/utils/request' // @符号是代表src的绝对路径

export default function(){
    // axios每次调用都会返回一个Promise对象
    // 将Promise对象返回，在App.vue再处理返回的数据
    return request.get('http://rap2api.taobao.org/app/mock/240993/test')
}
```

**修改App.vue**

```vue
<template>
  <div id="app">
    <ul>
      <li v-for="item in list" :key="item.id" v-text="item.name"></li>
    </ul>
  </div>
</template>

<script>
// 引入test.js测试axios封装
import testAPI from '@/api/test'

export default {
  data() {
    return {
      list: []
    }
  },
  created() {
    this.getData()
  },
  methods: {
    getData(){
      testAPI().then(response => {
        const resp = response.data
        this.list = resp.list
      })
    }
  },
}
</script>

<style></style>
```

**看到效果**

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/123959_f8ed1e07_5449551.png "屏幕截图.png")

**重构代码**

上面的代码是**黄金段位**的程序员写的，看看**钻石段位**程序员会怎么写

重构request.js

```js
// 引入axios
import axios from 'axios'

// 由于每次请求都会请求这个地址，所以可以把这个地址抽出来
const BASE_URL = 'http://rap2api.taobao.org/app/mock/240993'

// 创建一个axios对象
const request = axios.create({
    // 请求配置参考: https://github.com/axios/axios#request-config
    // baseURL参数是所有请求的路径前缀
    // 比如baseURL: '/dev-api'，调用axios.get('/test')，真正的请求路径是/dev-api/test
    baseURL: BASE_URL,
    timeout: 5000
})

// 导出request对象
export default request
```
重构test.js

```js
// 引入request
import request from '@/utils/request' // @符号是代表src的绝对路径

export default function () {
    // axios每次调用都会返回一个Promise对象
    // 将Promise对象返回，在App.vue再处理返回的数据
    // return request.get('http://rap2api.taobao.org/app/mock/240993/test')

    // 由于RAP2的地址已经抽到baseURL中，请求时会自动拼接，所以这里不需要再写RAP2的地址了
    return request.get('/test')
}
```

> 这里直接用Ajax请求向RAP2发请求，实际上是跨域了，但是请求依然成功了
> 原因是RAP2的响应头里面包含了：Access-Control-Allow-Origin: http://localhost:8888
> 所以是RAP2为我们做了跨域处理
> 不过在真实开发的过程中，前端不可能要求后端在每一个请求响应头是都加上Access-Control-Allow-Origin
> 这样也是不安全的，所以**跨域需要前端自己处理**

### 跨域处理
#### 添加请求代理
修改vue.config.js
```js
// Vue CLI将webpack.config.js封装起来，不建议我们直接修改，用vue.config.js来代替
module.exports = {
  devServer: {
    port: 8888, // 端口号
    host: "localhost", // 主机名
    https: false, // 是否启用https协议访问应用
    open: true, // 是否项目启动后马上打开浏览器访问
    // 代理配置
    proxy: {
      // 匹配/dev-api的请求
      '/dev-api': {
        // 代理转发地址
        target: 'http://rap2api.taobao.org/app/mock/240993',// 这个地址根据自己仓库地址定义
        // 在本地开启一个虚拟服务发送请求和接收数据，这样服务与服务之间不会存在跨域问题
        changeOrigin: true,
        // 路径字符串替换
        pathRewrite: {
          // 假如axios发请求到/dev-api/test
          // 经过代理的请求路径会变成http://rap2api.taobao.org/app/mock/240993/dev-api/test
          // 把路径中的/dev-api字符串替换成空字符串，就是把/dev-api去掉
          // 最终请求路径会编程http://rap2api.taobao.org/app/mock/240993/test
          '^/dev-api': ''
        }
      }
    }
  },

  lintOnSave: false, // 是否开启保存时进行代码检查
  productionSourceMap: false // 打包时不会生成.map文件，加快打包速度
};

```
#### 修改request.js
```js
// 引入axios
import axios from 'axios'

// 由于每次请求都会请求这个地址，所以可以把这个地址抽出来
// const BASE_URL = 'http://rap2api.taobao.org/app/mock/240993'

// 设置成代理服务匹配的地址
const BASE_URL = '/dev-api'

// 创建一个axios对象
const request = axios.create({
    // 请求配置参考: https://github.com/axios/axios#request-config
    // baseURL参数是所有请求的路径前缀
    // 比如baseURL: '/dev-api'，调用axios.get('/test')，真正的请求路径是/dev-api/test
    baseURL: BASE_URL,
    timeout: 5000
})

// 导出request对象
export default request
```

#### 修改request.js

```js
// 引入axios
import axios from 'axios'

// 由于每次请求都会请求这个地址，所以可以把这个地址抽出来
// const BASE_URL = 'http://rap2api.taobao.org/app/mock/240993'

// 设置成代理服务匹配的地址
// const BASE_URL = '/dev-api'

// 这里读取环境变量
const BASE_URL = process.env.VUE_APP_SERVICE_URI

// 创建一个axios对象
const request = axios.create({
    // 请求配置参考: https://github.com/axios/axios#request-config
    // baseURL参数是所有请求的路径前缀
    // 比如baseURL: '/dev-api'，调用axios.get('/test')，真正的请求路径是/dev-api/test
    baseURL: BASE_URL,
    timeout: 5000
})

// 导出request对象
export default request
```

#### 重启服务看效果
修改了vue.config.js需要重启服务
效果如下：

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/134346_c40b7255_5449551.png "屏幕截图.png")

> 现在我们已经通过代理服务发请求了，不用再担心跨域的问题
> 但是生产环境下，请求地址肯定不是RAP2了，需要配置真实的后端服务地址
> 如果想开发环境访问RAP2，生产环境访问真实后端服务地址，怎么动态切换呢？
> 我们需要为项目定义环境变量

### 环境变量

在项目根目录创建两个.env开头的文件配置环境变量

+ .env.development
+ .env.production

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/140058_a1cfcb31_5449551.png "屏幕截图.png")

#### 编写两个.env文件
**.env.development**

```env
VUE_APP_BASE_URL = http://rap2api.taobao.org/app/mock/240993
VUE_APP_SERVICE_URI = /dev-api
```

**.env.production**

```env
VUE_APP_SERVICE_URI = /prod-api
```

> 环境变量的命名必须有**VUE_APP**前缀
> 在JS中通过**process.env.**变量名调用
> 执行**serve**和**test:unit**命令时，会使用后缀为development的环境变量配置
> 执行**build**和**test:e2e**命令时，会使用后缀为production的环境变量配置

#### 修改vue.config.js
```js
// Vue CLI将webpack.config.js封装起来，不建议我们直接修改，用vue.config.js来代替
module.exports = {
  devServer: {
    port: 8888, // 端口号
    host: "localhost", // 主机名
    https: false, // 是否启用https协议访问应用
    open: true, // 是否项目启动后马上打开浏览器访问
    // 代理配置
    proxy: {
      // 匹配/dev-api的请求
      [process.env.VUE_APP_SERVICE_URI]: { // 用变量名来做key需要用中括号包裹
        // 代理转发地址
        target: process.env.VUE_APP_BASE_URL,// 这个地址根据自己仓库地址定义
        // 在本地开启一个虚拟服务发送请求和接收数据，这样服务与服务之间不会存在跨域问题
        changeOrigin: true,
        // 路径字符串替换
        pathRewrite: {
          // 假如axios发请求到/dev-api/test
          // 经过代理的请求路径会变成http://rap2api.taobao.org/app/mock/240993/dev-api/test
          // 把路径中的/dev-api字符串替换成空字符串，就是把/dev-api去掉
          // 最终请求路径会编程http://rap2api.taobao.org/app/mock/240993/test
          ['^'+ process.env.VUE_APP_SERVICE_URI]: '' // 用变量名来做key需要用中括号包裹
        }
      }
    }
  },

  lintOnSave: false, // 是否开启保存时进行代码检查
  productionSourceMap: false // 打包时不会生成.map文件，加快打包速度
};

```

重启服务看效果

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/142439_277c09c7_5449551.png "屏幕截图.png")

#### 生产环境部署

打包项目
```cmd
yarn build
```

把项目dist重命名后复制到Nginx的html目录下

> 不懂就参考[Vue进阶](Vue进阶.md)的**前端项目的部署**章节

修改nginx.conf的server配置
```shell
location / {
    # 根目录指向项目目录
    root   html/vue-member-manager;
    index  index.html index.htm;
}

# 添加访问代理
# 匹配/prod-api请求
location /prod-api {
    # 由于现在没有真实后端服务，所以还是用RAP2做演示
    proxy_pass   http://rap2api.taobao.org/app/mock/240993;
}
```

启动Nginx服务看效果，浏览器访问localhost

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/145240_fd3e173e_5449551.png "屏幕截图.png")

> 到这里为止项目环境算是搭建完成了
> 代码质量也从**钻石段位**升到了**王者段位**了
> 国服？管他呢-_-
> 下面就是建立代码管理

## 把代码托管给git
### 在码云上创建vue-member-manager

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/155253_21f0f439_5449551.png "屏幕截图.png")

> 记得把这一项的钩去掉，免得麻烦

### 本地git添加远程仓库
Vue CLI创建的项目会自动添加本地git仓库的，所以不需要用**git init**命令初始化项目。

添加远程仓库，在项目根目录进入命令行，执行命令

```cmd
git remote add gitee git@gitee.com:pjhpeter/vue-member-manager.git
```

> 后面的路径是自己的仓库路径
> 路径前的gitee参数是给这个远程仓库起的别名
> 以后推送或拉取代码都可以用别名来操作，不需要输入很长的地址

vscode中提交代码到本地仓库

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/162406_e400e6f5_5449551.png "屏幕截图.png")

点击这3ge点就有推送项了

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/163048_343c0823_5449551.png "屏幕截图.png")

选**push to...**

在vscode顶上出现输入框，就可以选择刚才添加的仓库**gitee**了

> 上面两步截不了图，没办法
>
> 好像多推送几次就可以不用**push to...**了，直接可以push了

代码就推送到码云了

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/163810_09263bed_5449551.png "屏幕截图.png")

## 登录功能
### 新建login分支
在码云上点击master，然后点击管理

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/165520_1519b63f_5449551.png "屏幕截图.png")

点击新建分支，输入login，点击提交

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/165633_64d3b4b6_5449551.png "屏幕截图.png")

在项目根目录下进入cmd，执行命令

```cmd
git pull gitee
```
这时会看到新建了分支的提示

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/170306_50194e85_5449551.png "屏幕截图.png")

切换成login分支

```cmd
git checkout login
```

查看当前分支

```cmd
git branch
```

看到分支已经切换成**login**了

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/170649_471e1679_5449551.png "屏幕截图.png")

### 需求分析
验证**用户名**和**密码**后才能登录，按**登录按钮**和按**回车键**都可以登录

![输入图片说明](https://images.gitee.com/uploads/images/2019/1227/172138_df0d14f1_5449551.png "屏幕截图.png")

### 配置路由
1. 在src目录下创建login文件夹，在login文件夹下创建index.vue
2. 修改src/router/index.js

```js
import Vue from "vue";
import VueRouter from "vue-router";
// 引入login组件
import Login from "@/views/login"; // 引入资源时，直接指向资源所在的文件夹，默认会引入文件夹下的index.vue

Vue.use(VueRouter);

const routes = [
  {
    // 登录界面
    path: "/login",
    component: Login
  }
];

const router = new VueRouter({
  routes
});

export default router;

```

3. 修改App.vue

```vue
<template>
  <div id="app">
    <router-view></router-view>
  </div>
</template>

<style>
  /* App.vue是整个应用的入口组件，这里一般会自定一些全局的样式，比如统一字体、body样式等 */
  body {
    font-family: Avenir,Tahoma,Arial,PingFang SC,Lantinghei SC,Microsoft Yahei,Hiragino Sans GB,Microsoft Sans Serif,WenQuanYi Micro Hei,Helvetica,sans-serif;
  }
</style>

```

### 登录页面
1. 编写src/views/login/index.vue
```vue
<template>
  <div class="login-content">
    <el-form :model="form" ref="form" label-width="80px" class="login-form">
      <h2 class="login-title">会员管理系统</h2>
      <el-form-item label="账号">
        <el-input v-model="form.username" placeholder="请输入账号"></el-input>
      </el-form-item>
      <el-form-item label="密码">
        <el-input type="password" v-model="form.password" placeholder="请输入密码"></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="login">登录</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
export default {
  data() {
    return {
      form: {
        username: "",
        password: ""
      }
    };
  },
  methods: {
    login() {}
  }
};
</script>

<style scoped>
.login-content {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-image: url("~@/assets/background.jpg"); /*在style中引用@全局路径，前面需要添加~*/
  background-size: 100%; /*背景图过尺寸大时，添加这个属性让背景图适应页面大小*/
}

.login-form {
  width: 350px;
  background-color: rgb(255, 255, 255, 0.8);
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 30px;
  border-radius: 20px;
}

.login-title {
  text-align: center;
  color: #303133;
}
</style>
```

2. 找一张背景图放到src/assets目录下，刷新一下看效果

### 表单校验
通过data的rules属性来约定验证规则，通过el-form-item的prop属性来指定需要验证的字段名。
1. 在el-form中绑定rules属性，在el-from-item中添加prop属性
```vue
<template>
  <div class="login-content">
    <el-form :model="form" :rules="rules" ref="form" label-width="80px" class="login-form">
      <h2 class="login-title">会员管理系统</h2>
      <el-form-item label="账号" prop="username">
        <el-input v-model="form.username" placeholder="请输入账号"></el-input>
      </el-form-item>
      <el-form-item label="密码" prop="password">
        <el-input type="password" v-model="form.password" placeholder="请输入密码"></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="login">登录</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>
```

2. 在data中添加rules属性
```js
data() {
  return {
    form: {
      username: "",
      password: ""
    },
    rules: {
      username: [{ required: true, message: "请输入账号", trigger: "blur" }],
      password: [{ required: true, message: "请输入密码", trigger: "blur" }]
    }
  };
}
```

3. login方法添加表单提交校验
```js
login() {
  // Vue时通过ref属性来获取template中的元素的
  this.$refs["form"].validate(vald => {
    if (vald) {
      // 登录
      console.log(this.form.username);
      console.log(this.form.password);
    } else {
      console.log("登录失败");
      return false;
    }
  });
}
```

### 添加按回车键登录
修改src/views/login/index.vue的template
```vue
<template>
  <div class="login-content">
    <el-form :model="form" :rules="rules" ref="form" label-width="80px" class="login-form">
      <h2 class="login-title">会员管理系统</h2>
      <el-form-item label="账号" prop="username">
        <!-- Element的组件如果要绑定原生事件，需要添加.natvie修饰符 -->
        <!-- 想了解监听键盘输入事件更多信息看文档：https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6 -->
        <el-input v-model="form.username" placeholder="请输入账号" @keypress.enter.native="login"></el-input>
      </el-form-item>
      <el-form-item label="密码" prop="password">
        <el-input
          type="password"
          v-model="form.password"
          placeholder="请输入密码"
          @keypress.enter.native="login"
        ></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="login">登录</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>
```

### RAP2中添加登录接口
1. 新建登录模块，新建登录验证接口

![输入图片说明](https://images.gitee.com/uploads/images/2019/1228/142410_574d4365_5449551.png "屏幕截图.png")

2. 导入响应数据

```json
{
    "code": 2000,
    "flag": true,
    "message": "验证成功",
    "data": {
        "token": "admin"
    }
}
```

3. 新建获取用户信息接口

![输入图片说明](https://images.gitee.com/uploads/images/2019/1228/143006_e4792aed_5449551.png "屏幕截图.png")

4. 导入响应数据

```json
{
    "code": 2000,
    "flag": true,
    "message": "成功获取用户信息",
    "data": {
        "id|1-10000": 1,
        "name": "@cname",
        "roles": [
            "manager"
        ]
    }
}
```

> 导入完后记得要手动修改id的规则

### 登录逻辑实现
1. 在src/api目录下创建login.js
```js
// 引入request
import request from "@/utils/request"

// 登录
export function login(username, password) {
    return request({
        url: "/user/login",
        method: "post",
        data: {
            username,
            password
        }
    });
};

// 通过token获取用户信息
export function getUserInfo(token) {
    return request({
        url: `/user/info/${token}`,
        method: "get"
    });
};
```

2. 修改src/views/login/index.vue的login方法
```js
login() {
      // Vue时通过ref属性来获取template中的元素的
      this.$refs["form"].validate(vald => {
        if (vald) {
          // 登录
          login(this.username, this.password).then(response => {
            const resp = response.data;
            if (resp.flag) {
              let token = resp.data.token;
              // 将token保存到本地缓存
              localStorage.setItem("user-token", token);
              // 获取用户信息
              getUserInfo(token).then(response => {
                const resp = response.data;
                if (resp.flag) {
                  // 将用户信息保存到本地缓存
                  localStorage.setItem("user-info", JSON.stringify(resp.data));
                  // 跳转到首页
                  this.$router.push("/");
                } else {
                  this.$message({
                    type: "warning",
                    message: resp.message
                  });
                }
              });
            } else {
              // Element提示信息，参考https://element.eleme.cn/#/zh-CN/component/message#message-xiao-xi-ti-shi
              this.$message({
                type: "warning",
                message: resp.message
              });
            }
          });
        } else {
          return false;
        }
      });
    }
  }
```
### 用Vuex保存全局状态信息
Vuex是Vue官方提供的插件，用来管理状态信息，在Vue的项目中，推荐用Vuex来管理token和用户信息等全局数据，同时也可以管理常量。
#### Vuex介绍
Vuex的使用方法如下：
```js
import Vue from "vue";
import Vuex from "vuex";

Vue.use(Vuex);

export default new Vuex.Store({
  // 全局状态信息
  state: {
    id: 0,
    name: ""
  },
  // mutations，用于改变state的值，但不写任何业务逻辑，类似JAVA的DAO层
  mutations: {
    // mutations中的方法推荐使用全大写命名
    SET_ID(state, id){// id是外面传入的参数，有个专业名称叫载荷
      state.id = id;
    },
    SET_NAME(state, name){
      state.name = name;
    }
  },
  // actions，用于编写业务逻辑代码，然后调用mutations去改变state的值
  actions: {
    // actions中的方法推荐使用首字母大写的驼峰式命名
    SetUser(context, id, name){
      // 业务代码
      // ......
      
      // 调用mutations，通过context.commit方法的第一个参数指定mutations的方法
      context.commit("SET_ID", id);
      context.commit("SET_NAME", name);
    }
  }
});
```
在其他组件中调用**Vuex**
```js
// 读取值
this.$store.state.name;

// 改变值
this.$store.dispatch("SetUser", id, name);
```
还可以模块化
```js
import Vue from "vue";
import Vuex from "vuex";

const user = {
  state: {
    id: 0,
    name: ""
  },
  mutations: {
    // 一些东西
  },
  actions: {
    // 一些东西
  }
}

Vue.use(Vuex);

export default new Vuex.Store({
  state: {},
  mutations: {},
  actions: {},
  modules: {
    user
  }
});
```

模块化的情况下要调用state的属性需要添加模块名user
```js
this.$store.state.user.name;
```

> 这里先简单介绍一下，感兴趣的去这里https://vuex.vuejs.org/zh/

#### 封装localStorage读写
在src/utils目录下创建auth.js，对localStorage的操作进行封装，方便调用。
```js
const TOKEN_KEY = "user-token";

const USER_INFO_KEY = "user-info";

// 获取token
export function getToken() {
    return localStorage.getItem(TOKEN_KEY);
}

// 保存token
export function setToken(token) {
    localStorage.setItem(TOKEN_KEY, token);
}

// 获取用户信息
export function getUserInfo() {
    return localStorage.getItem(JSON.parse(USER_INFO_KEY));
}

// 保存用户信息
export function setUserInfo(userInfo) {
    localStorage.setItem(USER_INFO_KEY, JSON.stringify(userInfo));
}

// 注销用户
export function logout() {
    localStorage.removeItem(USER_INFO_KEY);
    localStorage.removeItem(TOKEN_KEY);
}
```

#### 添加user的Vuex模块
1. 在src/store目录下创建modules文件夹,在modules文件夹下创建user.js
```js
// Vuex只能保证整个应用的所有组件都能拿到用户信息，但是刷新页面会清空，所以还是要在localStorage中存一份
import * as auth from "@/utils/auth";

import { login, getUserInfo } from "@/api/login"

const user = {
    state: {
        token: auth.getToken(), // 初始化与localStorage同步
        user: auth.getUserInfo() // 初始化与localStorage同步
    },
    mutations: {
        SET_TOKEN(state, token) {
            state.token = token;
            auth.setToken(token);
        },
        SET_USER_INFO(state, user) {
            state.user = user;
            auth.setUserInfo(user);
        }
    },
    actions: {
        // 将login的请求逻辑放到这里
        Login({ commit }, form) {
            // Promise是ES6处理异步请求的新方式，axios的链式调用也是通过Promise来实现的
            // resolve是成功的回调函数，其参数会作为then方法的参数传入
            // reject是失败的回调函数，其参数会作为catch方法的参数传入
            return new Promise((resolve, reject) => {
                login(form.username, form.password).then(response => {
                    const resp = response.data;
                    // 缓存token信息
                    commit("SET_TOKEN", resp.data.token);
                    resolve(resp);
                }).catch(error => {
                    reject(error);
                });
            });
        },
        // 获取用户信息的请求逻辑放到这里
        GetUserInfo({ commit }, token) {
            return new Promise((resolve, reject) => {
                getUserInfo(token).then(response => {
                    const resp = response.data;
                    // 缓存用户信息
                    commit("SET_USER_INFO", resp.data);
                    resolve(resp);
                }).catch(error => {
                    reject(error);
                });
            });
        }
    }
};

export default user;
```

2. 修改src/store/index.js
```js
import Vue from "vue";
import Vuex from "vuex";
// 引入user模块
import user from "./modules/user"

Vue.use(Vuex);

export default new Vuex.Store({
  state: {},
  mutations: {},
  actions: {},
  modules: {
    user // 添加user模块
  }
});

```

3. 修改src/views/login/index.vue的login方法
```js
login() {
  // Vue时通过ref属性来获取template中的元素的
  this.$refs["form"].validate(vald => {
    if (vald) {
      // 登录
      this.$store
        .dispatch("Login", this.form)
        .then(resp => {
          // 获取用户信息
          this.$store
            .dispatch("GetUserInfo", resp.data.token)
            .then(resp => {
              // 路由跳转
              this.$router.push("/");
            });
        });
    } else {
      return false;
    }
  });
}
```
> 现在可以正常登录了，但是如果直接在浏览器里面输入localhost:8888会直跳过登录页
> 所以必须要做一个浏览器的访问拦截

### 浏览器访问拦截
需求是这样，浏览器的访问除了login以外的路径全部都必须要登录才能访问，所以拦截的思路如下：
1. 是否访问login？如果是直接放行，不是继续下面判断
2. localStorage中是否有token，如果没有，跳转到login，如果有继续下面判断
3. localStorage中是否有用户信息，如果有直接跳转，如果没有则向后台请求用户信息
4. 请求用户信息成功后直接跳转，如果请求用户信息失败说明token有问题，跳转到login

根据上面的思路，在src目录下创建promission.js
```js
// 路由访问拦截是通过router的beforeEach方法实现
import router from "./router";

import store from "./store";

/*
 * from Route 从哪里来
 * to Route 到哪里去
 * next Function 重定向方法
 */
router.beforeEach((to, from, next) => {
    // 判断访问路径是否login
    if (to.path === "/login") {
        // 直接放行
        next();
    } else {
        // 判断localStorage有没有token
        const token = store.state.user.token;
        if (!token) {
            // 重定向到登录页
            next("/login");
        } else {
            // 判断localStorage中是否有用户信息
            const user = store.state.user.user;
            if (!user) {
                // 获取用户信息
                store.dispatch("GetUserInfo", token).then(resp => {
                    next();
                }).catch(error => {
                    next("/login");
                });
            } else {
                next();
            }
        }
    }
});
```
> 这里会获取用户信息，所以src/views/login/index.vue中就不需要获取了

修改src/views/login/index.vue
```js
login() {
  // Vue时通过ref属性来获取template中的元素的
  this.$refs["form"].validate(vald => {
    if (vald) {
      // 登录
      this.$store.dispatch("Login", this.form).then(resp => {
        // 路由跳转
        this.$router.push("/");
      });
    } else {
      return false;
    }
  });
}
```

> 终于都完成登录的功能了，万事开头难，哈哈^_^
> 还没完呢。。。刚才我们一直没有做异常处理吧
> 那是因为可以使用拦截器统一做的

### 统一拦截请求和响应
Axios提供了拦截器功能
+ axios.interceptors.request拦截请求
+ axios.interceptors.response拦截响应

修改src/utils/request.js
```js
// 引入axios
import axios from "axios";

// 引入Element UI的Message功能
import { Message } from "element-ui";

// 由于每次请求都会请求这个地址，所以可以把这个地址抽出来
// const BASE_URL = 'http://rap2api.taobao.org/app/mock/240993'

// 设置成代理服务匹配的地址
// const BASE_URL = '/dev-api'

// 这里读取环境变量
const BASE_URL = process.env.VUE_APP_SERVICE_URI;

// 创建一个axios对象
const request = axios.create({
  // 请求配置参考: https://github.com/axios/axios#request-config
  // baseURL参数是所有请求的路径前缀
  // 比如baseURL: '/dev-api'，调用axios.get('/test')，真正的请求路径是/dev-api/test
  baseURL: BASE_URL,
  timeout: 5000
});

// 请求拦截器
request.interceptors.request.use(config => {
  return config;
}, error => {
  return Promise.reject(error);
});

// 响应拦截器
request.interceptors.response.use(response => {
  // 即使response.status等于200也有可能会有异常
  // 所以一般都需要自定义返回码规则
  // 统一异常处理
  const resp = response.data;
  // 约定成功返回码为2000
  if (resp.code !== 2000) {
    Message({
      type: "warning",
      message: resp.message ? resp.message : "系统异常"
    });
  }
  return response;
}, error => {
    // 这回后台真的抛异常了
    // 异常处理
    Message({
      type: "error",
      message: `系统异常，错误码为：${error.response.status}`
    });
  return Promise.reject(error);
});

// 导出request对象
export default request;

```

> 到这里为止最难的部分已经完成啦
> 应该提交代码休息一下啦